'use strict';const settings=require("config.json")("./settings.json"),express=require("express"),bodyParser=require("body-parser"),{JSONRPC,JSONRPCResponse,JSONRPCServer}=require("json-rpc-2.0");
var {graphqlHTTP}=require("express-graphql"),{buildSchema}=require("graphql"),admin=require("./namespace_admin.js"),clique=require("./namespace_clique.js"),debug=require("./namespace_debug.js"),eth=require("./namespace_eth.js"),les=require("./namespace_les.js"),personal=require("./namespace_personal.js"),miner=require("./namespace_miner.js"),txpool=require("./namespace_txpool.js"),fs=require("fs"),mysql=require("mysql"),connection=mysql.createConnection({host:settings.database.host,database:settings.database.name,
port:settings.database.port,user:settings.database.user,password:settings.database.pass,multipleStatements:!0});
const typeDefinition="\n  # Bytes32 is a 32 byte binary string, represented as 0x-prefixed hexadecimal.\n  scalar Bytes32\n  # Address is a 20 byte Ethereum address, represented as 0x-prefixed hexadecimal.\n  scalar Address\n  # Bytes is an arbitrary length binary string, represented as 0x-prefixed hexadecimal.\n  # An empty byte string is represented as '0x'. Byte strings must have an even number of hexadecimal nybbles.\n  scalar Bytes\n  # BigInt is a large integer. Input is accepted as either a JSON number or as a string.\n  # Strings may be either decimal or 0x-prefixed hexadecimal. Output values are all\n  # 0x-prefixed hexadecimal.\n  scalar BigInt\n  # Long is a 64 bit unsigned integer.\n  scalar Long\n  schema {\n    query: Query\n    mutation: Mutation\n  }\n\n  # Account is an Ethereum account at a particular block.\n  type Account {\n      # Address is the address owning the account.\n      address: Address!\n      # Balance is the balance of the account, in wei.\n      balance: BigInt!\n      # TransactionCount is the number of transactions sent from this account,\n      # or in the case of a contract, the number of contracts created. Otherwise\n      # known as the nonce.\n      transactionCount: Long!\n      # Code contains the smart contract code for this account, if the account\n      # is a (non-self-destructed) contract.\n      code: Bytes!\n      # Storage provides access to the storage of a contract account, indexed\n      # by its 32 byte slot identifier.\n      storage(slot: Bytes32!): Bytes32!\n  }\n\n  # Log is an Ethereum event log.\n  type Log {\n      # Index is the index of this log in the block.\n      index: Int!\n      # Account is the account which generated this log - this will always\n      # be a contract account.\n      account(block: Long): Account!\n      # Topics is a list of 0-4 indexed topics for the log.\n      topics: [Bytes32!]!\n      # Data is unindexed data for this log.\n      data: Bytes!\n      # Transaction is the transaction that generated this log entry.\n      transaction: Transaction!\n  }\n  #EIP-2718 \n  type AccessTuple{\n      address: Address!\n      storageKeys : [Bytes32!]!\n  }\n  # Transaction is an Ethereum transaction.\n  type Transaction {\n      # Hash is the hash of this transaction.\n      hash: Bytes32!\n      # Nonce is the nonce of the account this transaction was generated with.\n      nonce: Long!\n      # Index is the index of this transaction in the parent block. This will\n      # be null if the transaction has not yet been mined.\n      index: Int\n      # From is the account that sent this transaction - this will always be\n      # an externally owned account.\n      from(block: Long): Account!\n      # To is the account the transaction was sent to. This is null for\n      # contract-creating transactions.\n      to(block: Long): Account\n      # Value is the value, in wei, sent along with this transaction.\n      value: BigInt!\n      # GasPrice is the price offered to miners for gas, in wei per unit.\n      gasPrice: BigInt!\n      # MaxFeePerGas is the maximum fee per gas offered to include a transaction, in wei. \n      maxFeePerGas: BigInt\n      # MaxPriorityFeePerGas is the maximum miner tip per gas offered to include a transaction, in wei. \n      maxPriorityFeePerGas: BigInt\n      # Gas is the maximum amount of gas this transaction can consume.\n      gas: Long!\n      # InputData is the data supplied to the target of the transaction.\n      inputData: Bytes!\n      # Block is the block this transaction was mined in. This will be null if\n      # the transaction has not yet been mined.\n      block: Block\n      # Status is the return status of the transaction. This will be 1 if the\n      # transaction succeeded, or 0 if it failed (due to a revert, or due to\n      # running out of gas). If the transaction has not yet been mined, this\n      # field will be null.\n      status: Long\n      # GasUsed is the amount of gas that was used processing this transaction.\n      # If the transaction has not yet been mined, this field will be null.\n      gasUsed: Long\n      # CumulativeGasUsed is the total gas used in the block up to and including\n      # this transaction. If the transaction has not yet been mined, this field\n      # will be null.\n      cumulativeGasUsed: Long\n      # EffectiveGasPrice is actual value per gas deducted from the sender's\n      # account. Before EIP-1559, this is equal to the transaction's gas price.\n      # After EIP-1559, it is baseFeePerGas + min(maxFeePerGas - baseFeePerGas,\n      # maxPriorityFeePerGas). Legacy transactions and EIP-2930 transactions are\n      # coerced into the EIP-1559 format by setting both maxFeePerGas and\n      # maxPriorityFeePerGas as the transaction's gas price.\n      effectiveGasPrice: BigInt\n      # CreatedContract is the account that was created by a contract creation\n      # transaction. If the transaction was not a contract creation transaction,\n      # or it has not yet been mined, this field will be null.\n      createdContract(block: Long): Account\n      # Logs is a list of log entries emitted by this transaction. If the\n      # transaction has not yet been mined, this field will be null.\n      logs: [Log!]\n      r: BigInt!\n      s: BigInt!\n      v: BigInt!\n      #Envelope transaction support\n      type: Int\n      accessList: [AccessTuple!]\n  }\n  # BlockFilterCriteria encapsulates log filter criteria for a filter applied\n  # to a single block.\n  input BlockFilterCriteria {\n      # Addresses is list of addresses that are of interest. If this list is\n      # empty, results will not be filtered by address.\n      addresses: [Address!]\n      # Topics list restricts matches to particular event topics. Each event has a list\n      # of topics. Topics matches a prefix of that list. An empty element array matches any\n      # topic. Non-empty elements represent an alternative that matches any of the\n      # contained topics.\n      #\n      # Examples:\n      #  - [] or nil          matches any topic list\n      #  - [[A]]              matches topic A in first position\n      #  - [[], [B]]          matches any topic in first position, B in second position\n      #  - [[A], [B]]         matches topic A in first position, B in second position\n      #  - [[A, B]], [C, D]]  matches topic (A OR B) in first position, (C OR D) in second position\n      topics: [[Bytes32!]!]\n  }\n  # Block is an Ethereum block.\n  type Block {\n      # Number is the number of this block, starting at 0 for the genesis block.\n      number: Long!\n      # Hash is the block hash of this block.\n      hash: Bytes32!\n      # Parent is the parent block of this block.\n      parent: Block\n      # Nonce is the block nonce, an 8 byte sequence determined by the miner.\n      nonce: Bytes!\n      # TransactionsRoot is the keccak256 hash of the root of the trie of transactions in this block.\n      transactionsRoot: Bytes32!\n      # TransactionCount is the number of transactions in this block. if\n      # transactions are not available for this block, this field will be null.\n      transactionCount: Int\n      # StateRoot is the keccak256 hash of the state trie after this block was processed.\n      stateRoot: Bytes32!\n      # ReceiptsRoot is the keccak256 hash of the trie of transaction receipts in this block.\n      receiptsRoot: Bytes32!\n      # Miner is the account that mined this block.\n      miner(block: Long): Account!\n      # ExtraData is an arbitrary data field supplied by the miner.\n      extraData: Bytes!\n      # GasLimit is the maximum amount of gas that was available to transactions in this block.\n      gasLimit: Long!\n      # GasUsed is the amount of gas that was used executing transactions in this block.\n      gasUsed: Long!\n      # BaseFeePerGas is the fee perunit of gas burned by the protocol in this block.\n      baseFeePerGas: BigInt\n      # Timestamp is the unix timestamp at which this block was mined.\n      timestamp: Long!\n      # LogsBloom is a bloom filter that can be used to check if a block may\n      # contain log entries matching a filter.\n      logsBloom: Bytes!\n      # MixHash is the hash that was used as an input to the PoW process.\n      mixHash: Bytes32!\n      # Difficulty is a measure of the difficulty of mining this block.\n      difficulty: BigInt!\n      # TotalDifficulty is the sum of all difficulty values up to and including\n      # this block.\n      totalDifficulty: BigInt!\n      # OmmerCount is the number of ommers (AKA uncles) associated with this\n      # block. If ommers are unavailable, this field will be null.\n      ommerCount: Int\n      # Ommers is a list of ommer (AKA uncle) blocks associated with this block.\n      # If ommers are unavailable, this field will be null. Depending on your\n      # node, the transactions, transactionAt, transactionCount, ommers,\n      # ommerCount and ommerAt fields may not be available on any ommer blocks.\n      ommers: [Block]\n      # OmmerAt returns the ommer (AKA uncle) at the specified index. If ommers\n      # are unavailable, or the index is out of bounds, this field will be null.\n      ommerAt(index: Int!): Block\n      # OmmerHash is the keccak256 hash of all the ommers (AKA uncles)\n      # associated with this block.\n      ommerHash: Bytes32!\n      # Transactions is a list of transactions associated with this block. If\n      # transactions are unavailable for this block, this field will be null.\n      transactions: [Transaction!]\n      # TransactionAt returns the transaction at the specified index. If\n      # transactions are unavailable for this block, or if the index is out of\n      # bounds, this field will be null.\n      transactionAt(index: Int!): Transaction\n      # Logs returns a filtered set of logs from this block.\n      logs(filter: BlockFilterCriteria!): [Log!]!\n      # Account fetches an Ethereum account at the current block's state.\n      account(address: Address!): Account!\n      # Call executes a local call operation at the current block's state.\n      call(data: CallData!): CallResult\n      # EstimateGas estimates the amount of gas that will be required for\n      # successful execution of a transaction at the current block's state.\n      estimateGas(data: CallData!): Long!\n  }\n  # CallData represents the data associated with a local contract call.\n  # All fields are optional.\n  input CallData {\n      # From is the address making the call.\n      from: Address\n      # To is the address the call is sent to.\n      to: Address\n      # Gas is the amount of gas sent with the call.\n      gas: Long\n      # GasPrice is the price, in wei, offered for each unit of gas.\n      gasPrice: BigInt\n      # MaxFeePerGas is the maximum fee per gas offered, in wei. \n      maxFeePerGas: BigInt\n      # MaxPriorityFeePerGas is the maximum miner tip per gas offered, in wei. \n      maxPriorityFeePerGas: BigInt\n      # Value is the value, in wei, sent along with the call.\n      value: BigInt\n      # Data is the data sent to the callee.\n      data: Bytes\n  }\n  # CallResult is the result of a local call operation.\n  type CallResult {\n      # Data is the return data of the called contract.\n      data: Bytes!\n      # GasUsed is the amount of gas used by the call, after any refunds.\n      gasUsed: Long!\n      # Status is the result of the call - 1 for success or 0 for failure.\n      status: Long!\n  }\n  # FilterCriteria encapsulates log filter criteria for searching log entries.\n  input FilterCriteria {\n      # FromBlock is the block at which to start searching, inclusive. Defaults\n      # to the latest block if not supplied.\n      fromBlock: Long\n      # ToBlock is the block at which to stop searching, inclusive. Defaults\n      # to the latest block if not supplied.\n      toBlock: Long\n      # Addresses is a list of addresses that are of interest. If this list is\n      # empty, results will not be filtered by address.\n      addresses: [Address!]\n      # Topics list restricts matches to particular event topics. Each event has a list\n      # of topics. Topics matches a prefix of that list. An empty element array matches any\n      # topic. Non-empty elements represent an alternative that matches any of the\n      # contained topics.\n      #\n      # Examples:\n      #  - [] or nil          matches any topic list\n      #  - [[A]]              matches topic A in first position\n      #  - [[], [B]]          matches any topic in first position, B in second position\n      #  - [[A], [B]]         matches topic A in first position, B in second position\n      #  - [[A, B]], [C, D]]  matches topic (A OR B) in first position, (C OR D) in second position\n      topics: [[Bytes32!]!]\n  }\n  # SyncState contains the current synchronisation state of the client.\n  type SyncState{\n      # StartingBlock is the block number at which synchronisation started.\n      startingBlock: Long!\n      # CurrentBlock is the point at which synchronisation has presently reached.\n      currentBlock: Long!\n      # HighestBlock is the latest known block number.\n      highestBlock: Long!\n  }\n  # Pending represents the current pending state.\n  type Pending {\n    # TransactionCount is the number of transactions in the pending state.\n    transactionCount: Int!\n    # Transactions is a list of transactions in the current pending state.\n    transactions: [Transaction!]\n    # Account fetches an Ethereum account for the pending state.\n    account(address: Address!): Account!\n    # Call executes a local call operation for the pending state.\n    call(data: CallData!): CallResult\n    # EstimateGas estimates the amount of gas that will be required for\n    # successful execution of a transaction for the pending state.\n    estimateGas(data: CallData!): Long!\n  }  \n  \n  type Query  {\n    # Block fetches an Ethereum block by number or by hash. If neither is\n    # supplied, the most recent known block is returned.\n    block(number: Long, hash: Bytes32): Block\n    # Blocks returns all the blocks between two numbers, inclusive. If\n    # to is not supplied, it defaults to the most recent known block.\n    blocks(from: Long, to: Long): [Block!]!\n    # Pending returns the current pending state.\n    pending: Pending!\n    # Transaction returns a transaction specified by its hash.\n    transaction(hash: Bytes32!): Transaction\n    # Logs returns log entries matching the provided filter.\n    logs(filter: FilterCriteria!): [Log!]!\n    # GasPrice returns the node's estimate of a gas price sufficient to\n    # ensure a transaction is mined in a timely fashion.\n    gasPrice: BigInt!\n    # MaxPriorityFeePerGas returns the node's estimate of a gas tip sufficient\n    # to ensure a transaction is mined in a timely fashion.\n    maxPriorityFeePerGas: BigInt!\n    # Syncing returns information on the current synchronisation state.\n    syncing: SyncState\n    # ChainID returns the current chain ID for transaction replay protection.\n    chainID: BigInt!\n  }\n\n  type Mutation {\n    # SendRawTransaction sends an RLP-encoded transaction to the network.\n    sendRawTransaction(data: Bytes!): Bytes32!\n  }\n",resolverObject=
{Query:{block(a,b,e){var c;a=`SELECT blocks WHERE number=${b.number} AND hash='${b.hash}'`;connection.connect();connection.query(a,function(d,f,g){if(d)throw d;console.log(f);c=f[0]});connection.end();return c},blocks(a,b,e){connection.connect();connection.query("SELECT * FROM blocks",function(c,d,f){if(c)throw c;console.log(d)});connection.end();return blocks},pending(){var a;connection.connect();connection.query("SELECT * FROM pending;",function(b,e,c){if(b)throw b;console.log(e);a=e});connection.end();
return a},transaction(a,b,e){var c;a=`SELECT * FROM transactions WHERE hash='${b.hash}';`;connection.connect();connection.query(a,function(d,f,g){if(d)throw d;console.log(f);c=f[0]});connection.end();return c},logs(a,b,e){var c;a=`SELECT * FROM logs WHERE ${b.filter}`;connection.connect();connection.query(a,function(d,f,g){if(d)throw d;console.log(f);c=f});connection.end();return c},gasPrice:()=>settings.gasPrice,maxPriorityFeePerGas:()=>0,syncing:()=>null,chainID:()=>settings.chainID},Mutation:{sendRawTransaction:a=>
a}},{makeExecutableSchema}=require("@graphql-tools/schema"),schema=makeExecutableSchema({typeDefs:typeDefinition,resolvers:resolverObject}),server=new JSONRPCServer;server.addMethod("echo",({text:a})=>a);server.addMethod("log",({message:a})=>console.log(a));server.addMethod("admin_addPeer",admin.admin_addPeer);server.addMethod("admin_datadir",admin.admin_datadir);server.addMethod("admin_nodeInfo",admin.admin_nodeInfo);server.addMethod("admin_peers",admin.admin_peers);
server.addMethod("admin_startRPC",admin.admin_startRPC);server.addMethod("admin_startWS",admin.admin_startWS);server.addMethod("admin_stopRPC",admin.admin_stopRPC);server.addMethod("admin_stopWS",admin.admin_stopWS);server.addMethod("clique_discard",clique.clique_discard);server.addMethod("clique_getSigners",clique.clique_getSigners);server.addMethod("clique_getSnapshot",clique.clique_getSnapshot);server.addMethod("clique_getSnapshotAtHash",clique.clique_getSnapshotAtHash);
server.addMethod("clique_proposals",clique.clique_proposals);server.addMethod("clique_propose",clique.clique_propose);server.addMethod("clique_status",clique.clique_status);server.addMethod("debug_backtraceAt",debug.debug_backtraceAt);server.addMethod("debug_blockProfile",debug.debug_blockProfile);server.addMethod("debug_cpuProfile",debug.debug_cpuProfile);server.addMethod("debug_dumpBlock",debug.debug_dumpBlock);server.addMethod("debug_gcStats",debug.debug_gcStats);
server.addMethod("debug_getBlockRlp",debug.debug_getBlockRlp);server.addMethod("debug_goTrace",debug.debug_goTrace);server.addMethod("debug_memStats",debug.debug_memStats);server.addMethod("debug_seedHash",debug.debug_seedHash);server.addMethod("debug_setBlockProfileRate",debug.debug_setBlockProfileRate);server.addMethod("debug_setHead",debug.debug_setHead);server.addMethod("debug_stacks",debug.debug_stacks);server.addMethod("debug_standardTraceBadBlockToFile",debug.debug_standardTraceBadBlockToFile);
server.addMethod("debug_standardTraceBlockToFile",debug.debug_standardTraceBlockToFile);server.addMethod("debug_startCPUProfile",debug.debug_startCPUProfile);server.addMethod("debug_startGoTrace",debug.debug_startGoTrace);server.addMethod("debug_stopCPUProfile",debug.debug_stopCPUProfile);server.addMethod("debug_stopGoTrace",debug.debug_stopGoTrace);server.addMethod("debug_traceBlock",debug.debug_traceBlock);server.addMethod("debug_traceBlockByHash",debug.debug_traceBlockByHash);
server.addMethod("debug_traceBlockByNumber",debug.debug_traceBlockByNumber);server.addMethod("debug_traceBlockFromFile",debug.debug_traceBlockFromFile);server.addMethod("debug_traceCall",debug.debug_traceCall);server.addMethod("debug_traceTransaction",debug.debug_traceTransaction);server.addMethod("debug_verbosity",debug.debug_verbosity);server.addMethod("debug_vmodule",debug.debug_vmodule);server.addMethod("debug_writeBlockProfile",debug.debug_writeBlockProfile);
server.addMethod("debug_writeMemProfile",debug.debug_writeMemProfile);server.addMethod("eth_call",eth.eth_call);server.addMethod("eth_subscribe",eth.subscribe);server.addMethod("eth_unsubscribe",eth.unsubscribe);server.addMethod("eth_createAccessList",eth.eth_createAccessList);server.addMethod("les_addBalance",les.les_addBalance);server.addMethod("les_clientInfo",les.les_clientInfo);server.addMethod("les_getCheckpoint",les.les_getCheckpoint);server.addMethod("les_getCheckpointContractAddress",les.les_getCheckpointContractAddress);
server.addMethod("les_latestCheckpoint",les.les_latestCheckpoint);server.addMethod("les_priorityClientInfo",les.les_priorityClientInfo);server.addMethod("les_serverInfo",les.les_serverInfo);server.addMethod("les_setClientParams",les.les_setClientParams);server.addMethod("les_setDefaultParams",les.les_setDefaultParams);server.addMethod("personal_ecRecover",personal.personal_ecRecover);server.addMethod("personal_importRawKey",personal.personal_importRawKey);
server.addMethod("personal_listAccounts",personal.personal_listAccounts);server.addMethod("personal_lockAccount",personal.personal_lockAccount);server.addMethod("personal_newAccount",personal.personal_newAccount);server.addMethod("personal_sendTransaction",personal.personal_sendTransaction);server.addMethod("personal_sign",personal.personal_sign);server.addMethod("personal_unlockAccount",personal.personal_unlockAccount);server.addMethod("miner_getHashrate",miner.miner_getHashrate);
server.addMethod("miner_setEtherbase",miner.miner_setEtherbase);server.addMethod("miner_setExtra",miner.miner_setExtra);server.addMethod("miner_setGasLimit",miner.miner_setGasLimit);server.addMethod("miner_setGasLimit",miner.miner_setGasPrice);server.addMethod("miner_start",miner.miner_start);server.addMethod("miner_stop",miner.miner_stop);server.addMethod("txpool_content",txpool.txpool_content);server.addMethod("txpool_inspect",txpool.txpool_inspect);server.addMethod("txpool_status",txpool.txpool_status);
const app=express();app.use(bodyParser.json());app.use("/graphql",graphqlHTTP({schema,rootValue:resolverObject,graphiql:!0}));app.post("/",(a,b)=>{server.receive(a.body).then(e=>{e?b.json(e):b.sendStatus(204)})});app.listen(settings.port,function(){console.log(`Private Ethereum Server listening on port ${settings.port}`)});